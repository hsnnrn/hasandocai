/**
 * Electron Main Process - Supabase OAuth Integration with Crashpad Fix
 * 
 * Bu dosya Windows'ta sık görülen crashpad_client_win.cc(863) not connected
 * hatasını önlemek için crashReporter ayarları ve GPU devre dışı bırakma
 * ile optimize edilmiştir. Supabase OAuth akışını destekler.
 */

import * as dotenv from "dotenv";
import * as path from 'path';

// .env'i kökten oku
dotenv.config({ path: path.resolve(process.cwd(), ".env") });
console.log("Loaded CLIENT_ID", process.env.SUPABASE_OAUTH_CLIENT_ID);

// Crash yakalama
process.on("uncaughtException", (err) => {
  console.error("❌ Uncaught Exception:", err);
});

process.on("unhandledRejection", (reason) => {
  console.error("❌ Unhandled Rejection:", reason);
});

import { app, BrowserWindow, ipcMain, crashReporter, shell, protocol } from 'electron';
import { readFile, writeFile, unlink, mkdir } from 'fs/promises';
import { homedir } from 'os';

// CrashReporter başlatma - Windows crashpad hatasını önlemek için
// uploadToServer: false ile crashpad'in upload denemesini engelliyoruz
crashReporter.start({
  productName: 'DocDataApp',
  companyName: 'YourCompany',
  submitURL: '', // Boş string - upload yapmayacak
  uploadToServer: false, // Bu ayar crashpad not connected uyarılarını azaltır
  ignoreSystemCrashHandler: false,
  rateLimit: false
});

// GPU ve donanım hızlandırma kontrolleri (dev için)
// Bu ayarlar app.whenReady() öncesinde yapılmalı
if (process.env.NODE_ENV === 'development' || !app.isPackaged) {
  // Development modunda GPU'yu devre dışı bırak
  app.commandLine.appendSwitch('disable-gpu');
  app.commandLine.appendSwitch('disable-gpu-compositing');
  app.commandLine.appendSwitch('disable-software-rasterizer');
  
  // Donanım hızlandırmayı tamamen kapatmak için
  app.disableHardwareAcceleration();
  app.commandLine.appendSwitch('disable-features', 'OutOfBlinkCors');
  
  console.log('Development mode: GPU acceleration disabled');
}

// Windows için AppUserModelId ayarlama
if (process.platform === 'win32') {
  try {
    app.setAppUserModelId('com.yourcompany.docdataapp');
    console.log('AppUserModelId set for Windows');
  } catch (error) {
    console.warn('Failed to set AppUserModelId:', error);
  }
}

// Global hata yakalama - main process hatalarını güvenli şekilde yakala
// Bu handler'lar yukarıda zaten tanımlandı, tekrar tanımlamaya gerek yok

// Global değişkenler
let mainWindow: BrowserWindow | null = null;
let oauthServer: any = null;
let tokenStorage: any = null;

// Auto-save directory path
const getAutoSavePath = () => {
  return path.join(homedir(), 'Documents', 'DocData');
};

// Ensure DocData directory exists
const ensureDocDataDirectory = async () => {
  const docDataPath = getAutoSavePath();
  try {
    await mkdir(docDataPath, { recursive: true });
    console.log('DocData directory ensured:', docDataPath);
  } catch (error) {
    console.error('Failed to create DocData directory:', error);
  }
};

// UUID validation helper
const isValidUUID = (value?: string): boolean => {
  if (!value) return false;
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  return uuidRegex.test(value);
};

// Environment variables validation
const validateEnvironment = () => {
  const clientId = process.env.SUPABASE_OAUTH_CLIENT_ID;
  const clientSecret = process.env.SUPABASE_OAUTH_CLIENT_SECRET;
  
  // Debug logging (masked)
  console.log('ENV CLIENT_ID present?', !!clientId);
  console.log('masked CLIENT_ID:', clientId ? clientId.slice(0,8)+'...'+clientId.slice(-4) : null);
  
  if (!isValidUUID(clientId)) {
    console.error('SUPABASE_OAUTH_CLIENT_ID is not set or invalid.');
    console.error('Expected format: UUID (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)');
    return false;
  }
  
  if (!clientSecret || clientSecret === 'your_client_secret_here') {
    console.warn('SUPABASE_OAUTH_CLIENT_SECRET is not set or is placeholder');
    console.warn('OAuth flow will use PKCE-only mode');
  }
  
  return true;
};

// Main window oluşturma fonksiyonu
function createMainWindow(): void {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'), // Preload script yolu
      sandbox: false // OAuth için gerekli
    },
    icon: path.join(__dirname, '../../assets/icon.svg'),
    autoHideMenuBar: true,
    show: false // İlk yükleme tamamlanana kadar gizle
  });

  // Load the React app
  const isDev = process.env.NODE_ENV === 'development' || !app.isPackaged;
  if (isDev) {
    mainWindow.loadURL('http://localhost:3000'); // Vite dev server
  } else {
    mainWindow.loadFile(path.join(__dirname, '../renderer/index.html'));
  }

  // Window hazır olduğunda göster
  mainWindow.once('ready-to-show', () => {
    if (mainWindow) {
      mainWindow.show();
    }
  });

  // Window kapatıldığında referansı temizle
  mainWindow.on('closed', () => {
    mainWindow = null;
  });

  // Development modunda DevTools'u aç
  if (isDev) {
    mainWindow.webContents.openDevTools();
  }
}

// OAuth popup window oluşturma fonksiyonu
function createAuthWindow(authUrl: string, redirectUri: string): Promise<{ success: boolean; code?: string; state?: string; error?: string }> {
  return new Promise((resolve) => {
    // Cross-platform window configuration
    const windowOptions: any = {
      width: 900,
      height: 700,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        sandbox: true,
        webSecurity: true
      },
      show: false,
      modal: true,
      parent: mainWindow || undefined,
      title: 'Supabase Authentication',
      titleBarStyle: process.platform === 'darwin' ? 'hiddenInset' : 'default'
    }

    // Platform-specific adjustments
    if (process.platform === 'win32') {
      windowOptions.icon = path.join(__dirname, 'assets/icon.ico')
    } else if (process.platform === 'darwin') {
      windowOptions.icon = path.join(__dirname, 'assets/icon.icns')
    }

    const authWindow = new BrowserWindow(windowOptions);

    // Redirect yakalama - will-redirect event
    authWindow.webContents.on('will-redirect', (event, navigationUrl) => {
      console.log('OAuth redirect detected:', navigationUrl);
      
      if (navigationUrl.startsWith(redirectUri)) {
        event.preventDefault();
        authWindow.close();
        
        try {
          const url = new URL(navigationUrl);
          const code = url.searchParams.get('code');
          const state = url.searchParams.get('state');
          const error = url.searchParams.get('error');
          
          if (error) {
            console.log('OAuth error:', error);
            resolve({ success: false, error: error });
            return;
          }
          
          if (code && state) {
            // Token'ları loglamıyoruz - sadece presence gösteriyoruz
            console.log('OAuth code received: [REDACTED]');
            console.log('OAuth state received: [REDACTED]');
            resolve({ success: true, code, state });
          } else {
            resolve({ success: false, error: 'Missing code or state parameter' });
          }
        } catch (error) {
          console.error('Failed to parse OAuth callback:', error);
          resolve({ success: false, error: 'Invalid callback URL' });
        }
      }
    });

    // will-navigate event (alternatif redirect yakalama)
    authWindow.webContents.on('will-navigate', (event, navigationUrl) => {
      if (navigationUrl.startsWith(redirectUri)) {
        event.preventDefault();
        authWindow.close();
        
        try {
          const url = new URL(navigationUrl);
          const code = url.searchParams.get('code');
          const state = url.searchParams.get('state');
          const error = url.searchParams.get('error');
          
          if (error) {
            resolve({ success: false, error: error });
            return;
          }
          
          if (code && state) {
            console.log('OAuth code received: [REDACTED]');
            console.log('OAuth state received: [REDACTED]');
            resolve({ success: true, code, state });
          } else {
            resolve({ success: false, error: 'Missing code or state parameter' });
          }
        } catch (error) {
          resolve({ success: false, error: 'Invalid callback URL' });
        }
      }
    });

    // Window kapatıldığında
    authWindow.on('closed', () => {
      resolve({ success: false, error: 'User closed the window' });
    });

    // URL'yi yükle
    authWindow.loadURL(authUrl);
    authWindow.show();
  });
}

// Token exchange fonksiyonu (main process'te güvenli)
async function exchangeCodeForToken(
  code: string,
  codeVerifier: string,
  redirectUri: string
): Promise<{ success: boolean; tokens?: any; error?: string }> {
  try {
    const tokenUrl = 'https://api.supabase.com/v1/oauth/token';
    const clientId = process.env.SUPABASE_OAUTH_CLIENT_ID;
    const clientSecret = process.env.SUPABASE_OAUTH_CLIENT_SECRET;
    
    if (!clientId) {
      throw new Error('SUPABASE_OAUTH_CLIENT_ID is not set');
    }
    
    const tokenData = new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: redirectUri,
      client_id: clientId,
      code_verifier: codeVerifier
    });
    
    // Client secret varsa ekle (PKCE-only flow için opsiyonel)
    if (clientSecret && clientSecret !== 'your_client_secret_here') {
      tokenData.append('client_secret', clientSecret);
    }

    console.log('Exchanging code for token...');
    
    const response = await fetch(tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
      },
      body: tokenData
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Token exchange failed: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
    }

    const tokenResponse = await response.json();
    console.log('Token exchange successful');

    // Prepare token data
    const tokens = {
      accessToken: tokenResponse.access_token,
      refreshToken: tokenResponse.refresh_token,
      expiresAt: Date.now() + (tokenResponse.expires_in * 1000),
      tokenType: tokenResponse.token_type || 'Bearer',
      scope: tokenResponse.scope || ''
    };

    return {
      success: true,
      tokens
    };

  } catch (error) {
    console.error('Token exchange error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Token exchange failed'
    };
  }
}

// PKCE code verifier ve challenge oluşturma
function generatePKCEPair() {
  const crypto = require('crypto');
  
  // Code verifier oluştur (43-128 karakter)
  const codeVerifier = crypto.randomBytes(32).toString('base64url');
  
  // Code challenge oluştur (SHA256 hash)
  const codeChallenge = crypto
    .createHash('sha256')
    .update(codeVerifier)
    .digest('base64url');
  
  return {
    codeVerifier,
    codeChallenge,
    codeChallengeMethod: 'S256'
  };
}

// State parameter oluşturma (CSRF koruması)
function generateState() {
  const crypto = require('crypto');
  return crypto.randomBytes(16).toString('base64url');
}

// Custom protocol handler for OAuth callback
function registerCustomProtocol(): void {
  const protocolName = 'myapp';
  
  // Register protocol handler
  app.setAsDefaultProtocolClient(protocolName);
  
  // Handle protocol URL
  app.on('open-url', (event, url) => {
    console.log('Received protocol URL:', url);
    
    if (url.startsWith(`${protocolName}://oauth/callback`)) {
      // Parse the callback URL
      const urlObj = new URL(url);
      const code = urlObj.searchParams.get('code');
      const state = urlObj.searchParams.get('state');
      const error = urlObj.searchParams.get('error');
      
      if (error) {
        console.error('OAuth error:', error);
        return;
      }
      
      if (code && state) {
        // Handle the callback (this would be integrated with the OAuth flow)
        console.log('OAuth callback received:', { code: '[REDACTED]', state: '[REDACTED]' });
      }
    }
  });
}

// App lifecycle events
app.whenReady().then(async () => {
  console.log('App is ready, initializing...');
  
  await ensureDocDataDirectory();
  
  // Environment validation
  if (!validateEnvironment()) {
    console.error('Environment validation failed. Please check your .env file.');
    // App continues but OAuth will fail gracefully
  }
  
  // Initialize OAuth services
  try {
    console.log('Starting OAuth services initialization...');
    
    // Import and initialize token storage
    const { createDefaultTokenStorage } = await import('./store');
    tokenStorage = createDefaultTokenStorage();
    console.log('Token storage initialized');
    
    // Import and initialize OAuth server
    const { getOAuthServer } = await import('./oauth-server');
    oauthServer = getOAuthServer(tokenStorage);
    console.log('OAuth server instance created');
    
    // Start OAuth server
    const oauthPort = parseInt(process.env.OAUTH_PORT || '3000');
    console.log('Starting OAuth server on port:', oauthPort);
    await oauthServer.start(oauthPort);
    console.log('OAuth server started successfully');
    
    // Register custom protocol
    registerCustomProtocol();
    console.log('Custom protocol registered');
    
    console.log('OAuth services initialized successfully');
  } catch (error) {
    console.error('❌ Failed to initialize OAuth services:', error);
    console.error('❌ Error details:', error);
    // Don't exit, continue without OAuth server
    oauthServer = null;
  }
  
  createMainWindow();
  console.log('App initialized successfully');
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createMainWindow();
  }
});

// Handle protocol on Windows
app.on('second-instance', (event, commandLine, workingDirectory) => {
  // Someone tried to run a second instance, focus our window instead
  if (mainWindow) {
    if (mainWindow.isMinimized()) mainWindow.restore();
    mainWindow.focus();
  }
  
  // Handle protocol URL from second instance
  const url = commandLine.find(arg => arg.startsWith('myapp://'));
  if (url) {
    console.log('Received protocol URL from second instance:', url);
    // Handle the URL
  }
});

// Make sure only one instance is running
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.quit();
}

// IPC Handlers

// OAuth başlatma handler'ı
ipcMain.handle('start-oauth', async (event, { authUrl, redirectUri }) => {
  try {
    console.log('Starting OAuth flow...');
    
    if (!authUrl || !redirectUri) {
      return { success: false, error: 'Missing authUrl or redirectUri' };
    }
    
    const result = await createAuthWindow(authUrl, redirectUri);
    
    if (result.success) {
      console.log('OAuth flow completed successfully');
      // NOTE: Token exchange burada yapılmalı (main process'te)
      // Client secret kullanılıyorsa kesinlikle renderer'a gönderilmemeli
    } else {
      console.log('OAuth flow failed:', result.error);
    }
    
    return result;
  } catch (error) {
    console.error('OAuth handler error:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
});

// Supabase OAuth handlers
ipcMain.handle('supabase:startAuth', async (event, options) => {
  try {
    console.log('Starting Supabase OAuth flow...');
    
    const { method = 'local' } = options;
    
    // Supabase OAuth URL oluştur
    const clientId = process.env.SUPABASE_OAUTH_CLIENT_ID;
    if (!clientId) {
      console.error('SUPABASE_OAUTH_CLIENT_ID is not set in environment variables');
      return {
        ok: false,
        error: 'OAuth client ID not configured. Please set SUPABASE_OAUTH_CLIENT_ID in your environment.'
      };
    }
    if (!isValidUUID(clientId)) {
      console.error('SUPABASE_OAUTH_CLIENT_ID is invalid. Expected format: UUID (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)');
      return {
        ok: false,
        error: 'Invalid OAuth client ID format. Please check your SUPABASE_OAUTH_CLIENT_ID configuration.'
      };
    }
    
    const redirectUri = method === 'local' 
      ? `http://localhost:${process.env.OAUTH_PORT || '54321'}/callback`
      : 'myapp://oauth/callback';
    
    // PKCE parameters oluştur
    const pkcePair = generatePKCEPair();
    const state = generateState();
    
    // Supabase'in kendi authorize sayfasını kullan - URL constructor ile güvenli
    const authUrl = new URL('https://api.supabase.com/v1/oauth/authorize');
    
    if (!clientId) {
      throw new Error("CLIENT_ID missing");
    }
    
    authUrl.searchParams.set('client_id', clientId);
    authUrl.searchParams.set('redirect_uri', redirectUri);
    authUrl.searchParams.set('response_type', 'code');
    authUrl.searchParams.set('scope', 'read:organizations read:projects read:api-keys');
    authUrl.searchParams.set('code_challenge', pkcePair.codeChallenge);
    authUrl.searchParams.set('code_challenge_method', pkcePair.codeChallengeMethod);
    authUrl.searchParams.set('state', state);
    
    console.log('Opening Supabase OAuth page:', authUrl.toString());
    
    // Supabase'in kendi OAuth sayfasını aç
    const result = await createAuthWindow(authUrl.toString(), redirectUri);
    
    if (result.success && result.code && result.state) {
      console.log('OAuth flow completed successfully');
      
      // Token exchange
      const tokenResult = await exchangeCodeForToken(
        result.code,
        pkcePair.codeVerifier,
        redirectUri
      );
      
      if (tokenResult.success) {
        // Token'ları güvenli şekilde sakla
        if (tokenStorage) {
          await tokenStorage.saveTokens(tokenResult.tokens);
        }
        
          // JWT token'ı decode ederek gerçek kullanıcı bilgilerini al
          try {
            console.log('Access token length:', tokenResult.tokens.accessToken.length);
            console.log('Access token preview:', tokenResult.tokens.accessToken.substring(0, 50) + '...');
            
            const tokenParts = tokenResult.tokens.accessToken.split('.');
            console.log('Token parts count:', tokenParts.length);
            
            if (tokenParts.length === 3) {
              try {
                // Base64 decode with padding
                let payloadBase64 = tokenParts[1];
                while (payloadBase64.length % 4) {
                  payloadBase64 += '=';
                }
                const payload = JSON.parse(Buffer.from(payloadBase64, 'base64').toString());
                console.log('JWT payload:', payload);
                console.log('JWT scopes:', payload.scope);
                console.log('JWT aud:', payload.aud);
                console.log('JWT iss:', payload.iss);
                console.log('JWT exp:', payload.exp);
                console.log('JWT iat:', payload.iat);
                console.log('JWT sub:', payload.sub);
                console.log('JWT email:', payload.email);
                console.log('JWT name:', payload.name);
                
                // JWT decode başarılı, kullanıcı bilgilerini al
                if (payload.email) {
                  console.log('JWT decode successful, using JWT data');
                  
                  // JWT'den kullanıcı bilgilerini aldıktan sonra da gerçek projeleri al
                  let projects: any[] = [];
                  let organizations: any[] = [];
                  
                  try {
                    // Önce organizasyonları al - farklı endpoint'ler dene
                    console.log('Fetching organizations from JWT flow...');
                    console.log('Token preview:', tokenResult.tokens.accessToken.substring(0, 50) + '...');
                    
                    // Önce direkt projeleri almaya çalış
                    console.log('Trying to fetch projects directly from JWT flow...');
                    let projectsResponse: Response | null = null;
                    
                    const projectEndpoints = [
                      'https://api.supabase.com/v1/projects',
                      'https://api.supabase.com/platform/projects',
                      'https://api.supabase.com/v1/me/projects'
                    ];
                    
                    for (const endpoint of projectEndpoints) {
                      try {
                        console.log(`Trying projects endpoint: ${endpoint}`);
                        projectsResponse = await fetch(endpoint, {
                          headers: {
                            'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                          }
                        });
                        
                        console.log(`Response status for ${endpoint}: ${projectsResponse.status}`);
                        console.log(`Response headers:`, Object.fromEntries(projectsResponse.headers.entries()));
                        
                        if (projectsResponse.ok) {
                          const responseText = await projectsResponse.text();
                          console.log(`Successfully connected to ${endpoint}`);
                          console.log(`Response body:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));
                          
                          try {
                            const projectsData = JSON.parse(responseText);
                            const directProjects = projectsData.projects || projectsData || [];
                            console.log(`Direct projects found from JWT flow:`, directProjects);
                            
                            if (directProjects.length > 0) {
                              projects = directProjects;
                              organizations = [{ id: 'default', name: 'Default Organization', slug: 'default-org' }];
                              console.log(`Successfully fetched ${directProjects.length} projects directly from JWT flow`);
                              break;
                            }
                          } catch (parseError) {
                            console.warn(`Failed to parse projects response from JWT flow:`, parseError);
                          }
                        } else {
                          const errorText = await projectsResponse.text();
                          console.warn(`Failed to fetch from ${endpoint}, status: ${projectsResponse.status}, error: ${errorText}`);
                          console.warn(`Error response headers:`, Object.fromEntries(projectsResponse.headers.entries()));
                        }
                      } catch (error) {
                        console.warn(`Error fetching from ${endpoint}:`, error);
                      }
                    }
                    
                    // Eğer direkt proje alma başarısız olursa, organizasyon yöntemini dene
                    if (projects.length === 0) {
                      console.log('Direct project fetch failed from JWT flow, trying organization method...');
                      
                      const orgEndpoints = [
                        'https://api.supabase.com/v1/organizations',
                        'https://api.supabase.com/platform/organizations',
                        'https://api.supabase.com/v1/me/organizations',
                        'https://api.supabase.com/v1/me',
                        'https://api.supabase.com/platform/profile'
                      ];
                    
                    let orgsResponse: Response | null = null;
                    let workingEndpoint: string | null = null;
                    
                    for (const endpoint of orgEndpoints) {
                      try {
                        console.log(`Trying organizations endpoint: ${endpoint}`);
                        orgsResponse = await fetch(endpoint, {
                          headers: {
                            'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                          }
                        });
                        
                        console.log(`Response status for ${endpoint}: ${orgsResponse.status}`);
                        console.log(`Response headers:`, Object.fromEntries(orgsResponse.headers.entries()));
                        
                        if (orgsResponse.ok) {
                          const responseText = await orgsResponse.text();
                          console.log(`Successfully connected to ${endpoint}`);
                          console.log(`Response body:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));
                          workingEndpoint = endpoint;
                          break;
                        } else {
                          const errorText = await orgsResponse.text();
                          console.warn(`Failed to fetch from ${endpoint}, status: ${orgsResponse.status}, error: ${errorText}`);
                          console.warn(`Error response headers:`, Object.fromEntries(orgsResponse.headers.entries()));
                        }
                      } catch (error) {
                        console.warn(`Error fetching from ${endpoint}:`, error);
                      }
                    }
                    
                    console.log(`Organizations API response status: ${orgsResponse?.status || 'No response'}`);
                    
                    if (orgsResponse && orgsResponse.ok) {
                      const orgsData = await orgsResponse.json();
                      organizations = orgsData.organizations || orgsData || [];
                      console.log('Organizations retrieved:', organizations);
                      console.log(`Working endpoint: ${workingEndpoint}`);
                      
                      // Her organizasyon için projeleri al - farklı endpoint'ler dene
                      for (const org of organizations) {
                        try {
                          console.log(`Fetching projects for organization: ${org.id} (${org.name})`);
                          
                    // Farklı proje endpoint'lerini dene - Supabase Management API
                    const projectEndpoints = [
                      `https://api.supabase.com/v1/organizations/${org.id}/projects`,
                      `https://api.supabase.com/platform/organizations/${org.id}/projects`,
                      `https://api.supabase.com/v1/projects?organization_id=${org.id}`,
                      `https://api.supabase.com/v1/projects`,
                      `https://api.supabase.com/platform/projects`,
                      `https://api.supabase.com/v1/me/projects`
                    ];
                          
                          let orgProjectsResponse: Response | null = null;
                          let projectsFound = false;
                          
                          for (const endpoint of projectEndpoints) {
                            try {
                              console.log(`Trying projects endpoint: ${endpoint}`);
                              orgProjectsResponse = await fetch(endpoint, {
                                headers: {
                                  'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                                  'Content-Type': 'application/json',
                                  'Accept': 'application/json'
                                }
                              });
                              
                              console.log(`Projects API response status for ${endpoint}: ${orgProjectsResponse.status}`);
                              
                              if (orgProjectsResponse.ok) {
                                const orgProjectsData = await orgProjectsResponse.json();
                                const orgProjects = orgProjectsData.projects || orgProjectsData || [];
                                console.log(`Projects for org ${org.id} from ${endpoint}:`, orgProjects);
                                
                                if (orgProjects.length > 0) {
                                  // Organizasyon bilgisini projelere ekle
                                  const projectsWithOrg = orgProjects.map(project => ({
                                    ...project,
                                    organization_name: org.name,
                                    organization_slug: org.slug
                                  }));
                                  
                                  projects = [...projects, ...projectsWithOrg];
                                  projectsFound = true;
                                  console.log(`Successfully fetched ${orgProjects.length} projects from ${endpoint}`);
                                  break;
                                }
                              } else {
                                const errorText = await orgProjectsResponse.text();
                                console.warn(`Projects API failed for ${endpoint}, status: ${orgProjectsResponse.status}, error: ${errorText}`);
                              }
                            } catch (error) {
                              console.warn(`Error fetching projects from ${endpoint}:`, error);
                            }
                          }
                          
                          if (!projectsFound) {
                            console.warn(`No projects found for organization ${org.id} (${org.name})`);
                          }
                        } catch (error) {
                          console.warn(`Error fetching projects for org ${org.id}:`, error);
                        }
                      }
                    } else {
                      if (orgsResponse) {
                        const errorText = await orgsResponse.text();
                        console.warn('All organizations API endpoints failed in JWT flow');
                        console.warn('Last response status:', orgsResponse.status);
                        console.warn('Last error response:', errorText);
                      } else {
                        console.warn('All organizations API endpoints failed in JWT flow - no successful response');
                      }
                    }
                  } catch (error) {
                    console.warn('Error fetching organizations and projects from JWT flow:', error);
                  }
                  
                  // Eğer hiçbir proje bulunamazsa, kullanıcıya bilgi ver
                  if (projects.length === 0) {
                    console.log('No projects found for user - this is normal for new accounts');
                    console.log('User should create a project in Supabase dashboard first');
                  }
                  
                  return {
                    ok: true,
                    message: 'OAuth completed successfully',
                    user: {
                      id: payload.sub || payload.user_id || 'user_' + Date.now(),
                      email: payload.email,
                      user_metadata: payload.user_metadata || {
                        full_name: payload.name || payload.email.split('@')[0] || 'Supabase User'
                      },
                      app_metadata: payload.app_metadata || {}
                    },
                    orgs: organizations.length > 0 ? organizations : [
                      { id: 'default', name: 'Default Organization', slug: 'default-org' }
                    ],
                    projects: projects
                  };
                }
              
            } catch (jwtError) {
              console.warn('JWT decode error:', jwtError);
            }
          }
          
            // JWT decode başarısızsa, Supabase Management API'den kullanıcı bilgilerini al
            console.log('JWT decode failed, trying Management API');
            console.log('Using access token for API calls:', tokenResult.tokens.accessToken.substring(0, 20) + '...');

            const userResponse = await fetch('https://api.supabase.com/platform/profile', {
              headers: {
                'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
              }
            });

            console.log(`User API response status: ${userResponse.status}`);
            console.log(`User API response headers:`, Object.fromEntries(userResponse.headers.entries()));

            if (userResponse.ok) {
              const userData = await userResponse.json();
              console.log('User data retrieved from Management API:', userData);
            
            // Gerçek projeleri al - doğru Supabase Management API endpoint'lerini kullan
            let projects: any[] = [];
            let organizations: any[] = [];
            
            try {
              // Önce organizasyonları al - farklı endpoint'ler dene
              console.log('Fetching organizations...');
              console.log('Token preview:', tokenResult.tokens.accessToken.substring(0, 50) + '...');
              
              // Önce direkt projeleri almaya çalış
              console.log('Trying to fetch projects directly...');
              let projectsResponse: Response | null = null;
              
              const projectEndpoints = [
                'https://api.supabase.com/v1/projects',
                'https://api.supabase.com/platform/projects',
                'https://api.supabase.com/v1/me/projects'
              ];
              
              for (const endpoint of projectEndpoints) {
                try {
                  console.log(`Trying projects endpoint: ${endpoint}`);
                  projectsResponse = await fetch(endpoint, {
                    headers: {
                      'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                      'Content-Type': 'application/json',
                      'Accept': 'application/json'
                    }
                  });
                  
                  console.log(`Response status for ${endpoint}: ${projectsResponse.status}`);
                  console.log(`Response headers:`, Object.fromEntries(projectsResponse.headers.entries()));
                  
                  if (projectsResponse.ok) {
                    const responseText = await projectsResponse.text();
                    console.log(`Successfully connected to ${endpoint}`);
                    console.log(`Response body:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));
                    
                    try {
                      const projectsData = JSON.parse(responseText);
                      const directProjects = projectsData.projects || projectsData || [];
                      console.log(`Direct projects found:`, directProjects);
                      
                      if (directProjects.length > 0) {
                        projects = directProjects;
                        organizations = [{ id: 'default', name: 'Default Organization', slug: 'default-org' }];
                        console.log(`Successfully fetched ${directProjects.length} projects directly`);
                        break;
                      }
                    } catch (parseError) {
                      console.warn(`Failed to parse projects response:`, parseError);
                    }
                  } else {
                    const errorText = await projectsResponse.text();
                    console.warn(`Failed to fetch from ${endpoint}, status: ${projectsResponse.status}, error: ${errorText}`);
                    console.warn(`Error response headers:`, Object.fromEntries(projectsResponse.headers.entries()));
                  }
                } catch (error) {
                  console.warn(`Error fetching from ${endpoint}:`, error);
                }
              }
              
              // Eğer direkt proje alma başarısız olursa, organizasyon yöntemini dene
              if (projects.length === 0) {
                console.log('Direct project fetch failed, trying organization method...');
                
                const orgEndpoints = [
                  'https://api.supabase.com/v1/organizations',
                  'https://api.supabase.com/platform/organizations',
                  'https://api.supabase.com/v1/me/organizations',
                  'https://api.supabase.com/v1/me',
                  'https://api.supabase.com/platform/profile'
                ];
                
                let orgsResponse: Response | null = null;
                let workingEndpoint: string | null = null;
                
                for (const endpoint of orgEndpoints) {
                  try {
                    console.log(`Trying organizations endpoint: ${endpoint}`);
                    orgsResponse = await fetch(endpoint, {
                      headers: {
                        'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                      }
                    });
                    
                    console.log(`Response status for ${endpoint}: ${orgsResponse.status}`);
                    console.log(`Response headers:`, Object.fromEntries(orgsResponse.headers.entries()));
                    
                    if (orgsResponse.ok) {
                      const responseText = await orgsResponse.text();
                      console.log(`Successfully connected to ${endpoint}`);
                      console.log(`Response body:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));
                      workingEndpoint = endpoint;
                      break;
                    } else {
                      const errorText = await orgsResponse.text();
                      console.warn(`Failed to fetch from ${endpoint}, status: ${orgsResponse.status}, error: ${errorText}`);
                      console.warn(`Error response headers:`, Object.fromEntries(orgsResponse.headers.entries()));
                    }
                  } catch (error) {
                    console.warn(`Error fetching from ${endpoint}:`, error);
                  }
                }
              
              console.log(`Organizations API response status: ${orgsResponse?.status || 'No response'}`);
              
              if (orgsResponse && orgsResponse.ok) {
                const orgsData = await orgsResponse.json();
                organizations = orgsData.organizations || orgsData || [];
                console.log('Organizations retrieved:', organizations);
                console.log(`Working endpoint: ${workingEndpoint}`);
                
                // Her organizasyon için projeleri al - farklı endpoint'ler dene
                for (const org of organizations) {
                  try {
                    console.log(`Fetching projects for organization: ${org.id} (${org.name})`);
                    
                    // Farklı proje endpoint'lerini dene - Supabase Management API
            const projectEndpoints = [
                      `https://api.supabase.com/v1/organizations/${org.id}/projects`,
                      `https://api.supabase.com/platform/organizations/${org.id}/projects`,
                      `https://api.supabase.com/v1/projects?organization_id=${org.id}`,
                      `https://api.supabase.com/v1/projects`,
                      `https://api.supabase.com/platform/projects`,
                      `https://api.supabase.com/v1/me/projects`
                    ];
                    
                    let orgProjectsResponse: Response | null = null;
                    let projectsFound = false;
            
            for (const endpoint of projectEndpoints) {
              try {
                console.log(`Trying projects endpoint: ${endpoint}`);
                        orgProjectsResponse = await fetch(endpoint, {
                  headers: {
                    'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                  }
                });
                
                        console.log(`Projects API response status for ${endpoint}: ${orgProjectsResponse.status}`);
                        
                        if (orgProjectsResponse.ok) {
                          const orgProjectsData = await orgProjectsResponse.json();
                          const orgProjects = orgProjectsData.projects || orgProjectsData || [];
                          console.log(`Projects for org ${org.id} from ${endpoint}:`, orgProjects);
                          
                          if (orgProjects.length > 0) {
                            // Organizasyon bilgisini projelere ekle
                            const projectsWithOrg = orgProjects.map(project => ({
                              ...project,
                              organization_name: org.name,
                              organization_slug: org.slug
                            }));
                            
                            projects = [...projects, ...projectsWithOrg];
                            projectsFound = true;
                            console.log(`Successfully fetched ${orgProjects.length} projects from ${endpoint}`);
                  break;
                          }
                } else {
                          const errorText = await orgProjectsResponse.text();
                          console.warn(`Projects API failed for ${endpoint}, status: ${orgProjectsResponse.status}, error: ${errorText}`);
                }
              } catch (error) {
                console.warn(`Error fetching projects from ${endpoint}:`, error);
              }
            }
            
                    if (!projectsFound) {
                      console.warn(`No projects found for organization ${org.id} (${org.name})`);
                    }
                  } catch (error) {
                    console.warn(`Error fetching projects for org ${org.id}:`, error);
                  }
                }
              } else {
                if (orgsResponse) {
                  const errorText = await orgsResponse.text();
                  console.warn('All organizations API endpoints failed');
                  console.warn('Last response status:', orgsResponse.status);
                  console.warn('Last error response:', errorText);
                } else {
                  console.warn('All organizations API endpoints failed - no successful response');
                }
              }
            } catch (error) {
              console.warn('Error fetching organizations and projects:', error);
            }
            
            // Eğer hiçbir proje bulunamazsa, kullanıcıya bilgi ver ve boş liste döndür
            if (projects.length === 0) {
              console.log('No projects found for user - this is normal for new accounts');
              console.log('User should create a project in Supabase dashboard first');
              console.log('Returning empty projects array instead of mock data');
            } else {
              console.log(`Successfully fetched ${projects.length} real projects from Supabase API`);
            }
            
            return {
              ok: true,
              message: 'OAuth completed successfully',
              user: {
                id: userData.id || 'user_' + Date.now(),
                email: userData.email || 'user@supabase.com',
                user_metadata: userData.user_metadata || {
                  full_name: userData.email || 'Supabase User'
                },
                app_metadata: userData.app_metadata || {}
              },
              orgs: organizations.length > 0 ? organizations : [
                { id: 'default', name: 'Default Organization', slug: 'default-org' }
              ],
              projects: projects
            };
            } else {
              const errorText = await userResponse.text();
              console.warn('Management API failed, status:', userResponse.status);
              console.warn('Management API error response:', errorText);
            }
        } catch (error) {
          console.warn('Error fetching user data:', error);
        }
        
        // Fallback: User API failed, but still try to get projects with the token
        console.log('User API failed, trying to get projects directly...');
        console.log('Access token that failed user API:', tokenResult.tokens.accessToken.substring(0, 50) + '...');
        
        let projects: any[] = [];
        let organizations: any[] = [];
        
        try {
          // Önce organizasyonları al - farklı endpoint'ler dene
          console.log('Fetching organizations from fallback flow...');
          console.log('Token preview:', tokenResult.tokens.accessToken.substring(0, 50) + '...');
          
          // Önce direkt projeleri almaya çalış
          console.log('Trying to fetch projects directly from fallback flow...');
          let projectsResponse: Response | null = null;
          
          const projectEndpoints = [
            'https://api.supabase.com/v1/projects',
            'https://api.supabase.com/platform/projects',
            'https://api.supabase.com/v1/me/projects'
          ];
          
          for (const endpoint of projectEndpoints) {
            try {
              console.log(`Trying projects endpoint: ${endpoint}`);
              projectsResponse = await fetch(endpoint, {
                headers: {
                  'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                  'Content-Type': 'application/json',
                  'Accept': 'application/json'
                }
              });
              
              console.log(`Response status for ${endpoint}: ${projectsResponse.status}`);
              console.log(`Response headers:`, Object.fromEntries(projectsResponse.headers.entries()));
              
              if (projectsResponse.ok) {
                const responseText = await projectsResponse.text();
                console.log(`Successfully connected to ${endpoint}`);
                console.log(`Response body:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));
                
                try {
                  const projectsData = JSON.parse(responseText);
                  const directProjects = projectsData.projects || projectsData || [];
                  console.log(`Direct projects found from fallback flow:`, directProjects);
                  
                  if (directProjects.length > 0) {
                    projects = directProjects;
                    organizations = [{ id: 'default', name: 'Default Organization', slug: 'default-org' }];
                    console.log(`Successfully fetched ${directProjects.length} projects directly from fallback flow`);
                    break;
                  }
                } catch (parseError) {
                  console.warn(`Failed to parse projects response from fallback flow:`, parseError);
                }
              } else {
                const errorText = await projectsResponse.text();
                console.warn(`Failed to fetch from ${endpoint}, status: ${projectsResponse.status}, error: ${errorText}`);
                console.warn(`Error response headers:`, Object.fromEntries(projectsResponse.headers.entries()));
              }
            } catch (error) {
              console.warn(`Error fetching from ${endpoint}:`, error);
            }
          }
          
          // Eğer direkt proje alma başarısız olursa, organizasyon yöntemini dene
          if (projects.length === 0) {
            console.log('Direct project fetch failed from fallback flow, trying organization method...');
            
            const orgEndpoints = [
              'https://api.supabase.com/v1/organizations',
              'https://api.supabase.com/platform/organizations',
              'https://api.supabase.com/v1/me/organizations',
              'https://api.supabase.com/v1/me',
              'https://api.supabase.com/platform/profile'
            ];
          
          let orgsResponse: Response | null = null;
          let workingEndpoint: string | null = null;
          
          for (const endpoint of orgEndpoints) {
            try {
              console.log(`Trying organizations endpoint: ${endpoint}`);
              orgsResponse = await fetch(endpoint, {
                headers: {
                  'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                  'Content-Type': 'application/json',
                  'Accept': 'application/json'
                }
              });
              
              console.log(`Response status for ${endpoint}: ${orgsResponse.status}`);
              console.log(`Response headers:`, Object.fromEntries(orgsResponse.headers.entries()));
              
              if (orgsResponse.ok) {
                const responseText = await orgsResponse.text();
                console.log(`Successfully connected to ${endpoint}`);
                console.log(`Response body:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));
                workingEndpoint = endpoint;
                break;
              } else {
                const errorText = await orgsResponse.text();
                console.warn(`Failed to fetch from ${endpoint}, status: ${orgsResponse.status}, error: ${errorText}`);
                console.warn(`Error response headers:`, Object.fromEntries(orgsResponse.headers.entries()));
              }
            } catch (error) {
              console.warn(`Error fetching from ${endpoint}:`, error);
            }
          }
          
          console.log(`Organizations API response status: ${orgsResponse?.status || 'No response'}`);
          
          if (orgsResponse && orgsResponse.ok) {
            const orgsData = await orgsResponse.json();
            organizations = orgsData.organizations || orgsData || [];
            console.log('Organizations retrieved:', organizations);
            console.log(`Working endpoint: ${workingEndpoint}`);
            
            // Her organizasyon için projeleri al - farklı endpoint'ler dene
            for (const org of organizations) {
              try {
                console.log(`Fetching projects for organization: ${org.id} (${org.name})`);
                
                    // Farklı proje endpoint'lerini dene - Supabase Management API
                    const projectEndpoints = [
                      `https://api.supabase.com/v1/organizations/${org.id}/projects`,
                      `https://api.supabase.com/platform/organizations/${org.id}/projects`,
                      `https://api.supabase.com/v1/projects?organization_id=${org.id}`,
                      `https://api.supabase.com/v1/projects`,
                      `https://api.supabase.com/platform/projects`,
                      `https://api.supabase.com/v1/me/projects`
                    ];
                
                let orgProjectsResponse: Response | null = null;
                let projectsFound = false;
                
                for (const endpoint of projectEndpoints) {
                  try {
                    console.log(`Trying projects endpoint: ${endpoint}`);
                    orgProjectsResponse = await fetch(endpoint, {
                      headers: {
                        'Authorization': `Bearer ${tokenResult.tokens.accessToken}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                      }
                    });
                    
                    console.log(`Projects API response status for ${endpoint}: ${orgProjectsResponse.status}`);
                    
                    if (orgProjectsResponse.ok) {
                      const orgProjectsData = await orgProjectsResponse.json();
                      const orgProjects = orgProjectsData.projects || orgProjectsData || [];
                      console.log(`Projects for org ${org.id} from ${endpoint}:`, orgProjects);
                      
                      if (orgProjects.length > 0) {
                        // Organizasyon bilgisini projelere ekle
                        const projectsWithOrg = orgProjects.map(project => ({
                          ...project,
                          organization_name: org.name,
                          organization_slug: org.slug
                        }));
                        
                        projects = [...projects, ...projectsWithOrg];
                        projectsFound = true;
                        console.log(`Successfully fetched ${orgProjects.length} projects from ${endpoint}`);
                        break;
                      }
                    } else {
                      const errorText = await orgProjectsResponse.text();
                      console.warn(`Projects API failed for ${endpoint}, status: ${orgProjectsResponse.status}, error: ${errorText}`);
                    }
                  } catch (error) {
                    console.warn(`Error fetching projects from ${endpoint}:`, error);
                  }
                }
                
                if (!projectsFound) {
                  console.warn(`No projects found for organization ${org.id} (${org.name})`);
                }
              } catch (error) {
                console.warn(`Error fetching projects for org ${org.id}:`, error);
              }
            }
          } else {
            if (orgsResponse) {
              const errorText = await orgsResponse.text();
              console.warn('All organizations API endpoints failed in fallback flow');
              console.warn('Last response status:', orgsResponse.status);
              console.warn('Last error response:', errorText);
            } else {
              console.warn('All organizations API endpoints failed in fallback flow - no successful response');
            }
          }
        } catch (error) {
          console.warn('Error fetching organizations and projects from fallback flow:', error);
        }
        
        // Eğer hiçbir proje bulunamazsa, kullanıcıya bilgi ver
        if (projects.length === 0) {
          console.log('No projects found for user - this is normal for new accounts');
          console.log('User should create a project in Supabase dashboard first');
        }
        
        return {
          ok: true,
          message: 'OAuth completed successfully',
          user: {
            id: 'user_' + Date.now(),
            email: 'user@supabase.com',
            user_metadata: {
              full_name: 'Supabase User'
            }
          },
          orgs: organizations.length > 0 ? organizations : [
            { id: 'default', name: 'Default Organization', slug: 'default-org' }
          ],
          projects: projects
        };
      } else {
        return {
          ok: false,
          error: tokenResult.error || 'Token exchange failed'
        };
      }
    } else {
      return {
        ok: false,
        error: result.error || 'OAuth flow failed'
      };
    }
  } catch (error) {
    console.error('Supabase OAuth error:', error);
    return {
      ok: false,
      error: error instanceof Error ? error.message : 'OAuth failed'
    };
  }
});

ipcMain.handle('supabase:getAuthStatus', async () => {
  try {
    if (!tokenStorage) {
      return {
        ok: false,
        error: 'Token storage not initialized'
      };
    }
    
    const tokens = await tokenStorage.getTokens();
    const status = await tokenStorage.getStorageStatus();
    
    return {
      ok: true,
      hasTokens: !!tokens,
      isTokenValid: tokens ? tokens.expiresAt > Date.now() : false,
      storageMethod: status.storageMethod,
      message: 'Auth status checked'
    };
  } catch (error) {
    console.error('Get auth status error:', error);
    return {
      ok: false,
      error: error instanceof Error ? error.message : 'Failed to get auth status'
    };
  }
});

ipcMain.handle('supabase:logout', async () => {
  try {
    if (!tokenStorage) {
      return {
        ok: false,
        error: 'Token storage not initialized'
      };
    }
    
    // Tüm token'ları temizle
    await tokenStorage.clearAll();
    console.log('Tokens deleted');
    
    // OAuth server'ı durdur
    if (oauthServer) {
      await oauthServer.stop();
      oauthServer = null;
    }
    
    // Tüm auth verilerini temizle
    try {
      // Keytar'dan tüm kayıtları temizle
      const keytar = require('keytar');
      const serviceName = 'DocDataApp';
      
      // Tüm kayıtları al ve sil
      const credentials = await keytar.findCredentials(serviceName);
      for (const credential of credentials) {
        await keytar.deletePassword(serviceName, credential.account);
      }
      console.log('All auth data cleared');
      
      // Electron session'ından çerezleri temizle
      if (mainWindow && mainWindow.webContents) {
        const session = mainWindow.webContents.session;
        
        // Tüm çerezleri temizle
        await session.clearStorageData({
          storages: ['cookies', 'localstorage', 'indexdb', 'websql', 'cachestorage']
        });
        
        // Supabase domain'lerindeki çerezleri özellikle temizle
        const supabaseDomains = [
          'supabase.com',
          'api.supabase.com',
          'frontend-assets.supabase.com',
          'ph.supabase.com',
          'configcat.supabase.com'
        ];
        
        for (const domain of supabaseDomains) {
          try {
            await session.clearStorageData({
              origin: `https://${domain}`,
              storages: ['cookies', 'localstorage', 'indexdb', 'websql', 'cachestorage']
            });
            console.log(`Cleared storage for ${domain}`);
          } catch (domainError) {
            console.warn(`Error clearing storage for ${domain}:`, domainError);
          }
        }
        
        console.log('Electron session storage cleared');
      }
    } catch (keytarError) {
      console.warn('Keytar cleanup error:', keytarError);
    }
    
    console.log('Supabase logout successful');
    return {
      ok: true,
      message: 'Logged out successfully'
    };
  } catch (error) {
    console.error('Supabase logout error:', error);
    return {
      ok: false,
      error: error instanceof Error ? error.message : 'Logout failed'
    };
  }
});

// File processing handlers
ipcMain.handle('file:process', async (event, filePath, options) => {
  try {
    console.log('File processing started for:', filePath);
    
    const fs = await import('fs/promises');
    const fileBuffer = await fs.readFile(filePath);
    
    // Using ConvertAPI for processing
    const { ConvertAPIService } = await import('./services/ConvertAPIService');
    const convertAPI = new ConvertAPIService('<YOUR_CONVERTAPI_KEY>');
    
    let result;
    const fileExtension = filePath.toLowerCase().split('.').pop();
    const isPdfFile = fileExtension === 'pdf';
    
    if (isPdfFile && options.outputFormat === 'docx') {
        result = await convertAPI.convertPDFToDOCX(fileBuffer, path.basename(filePath), options.outputDirectory);
      } else {
        // Fallback to PDF to DOCX
        result = await convertAPI.convertPDFToDOCX(fileBuffer, path.basename(filePath), options.outputDirectory);
    }
    
    return result;
  } catch (error) {
    console.error('File processing error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    };
  }
});

// File operations
ipcMain.handle('file:open', async () => {
  const { dialog } = await import('electron');
  const result = await dialog.showOpenDialog(mainWindow!, {
    properties: ['openFile'],
    filters: [
      { name: 'PDF Files', extensions: ['pdf'] },
      { name: 'Image Files', extensions: ['jpg', 'jpeg', 'png', 'bmp', 'gif', 'tiff'] },
      { name: 'Word Documents', extensions: ['doc', 'docx'] },
      { name: 'All Files', extensions: ['*'] }
    ]
  });
  
  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths[0];
  }
  return null;
});

ipcMain.handle('file:save', async (event, data, defaultName) => {
  const { dialog } = await import('electron');
  const result = await dialog.showSaveDialog(mainWindow!, {
    defaultPath: defaultName,
    filters: [
      { name: 'PDF Files', extensions: ['pdf'] },
      { name: 'Word Documents', extensions: ['docx'] },
      { name: 'Image Files', extensions: ['jpg', 'jpeg', 'png', 'bmp', 'gif', 'tiff'] },
      { name: 'All Files', extensions: ['*'] }
    ]
  });
  
  if (!result.canceled && result.filePath) {
    const fs = await import('fs/promises');
    await fs.writeFile(result.filePath, data);
    return result.filePath;
  }
  return null;
});

// Directory selection
ipcMain.handle('selectDirectory', async () => {
  const { dialog } = await import('electron');
  const result = await dialog.showOpenDialog(mainWindow!, {
    properties: ['openDirectory'],
    title: 'Select Output Directory'
  });
  
  if (!result.canceled && result.filePaths.length > 0) {
    return result.filePaths[0];
  }
  return null;
});

// Default directory
ipcMain.handle('getDefaultDirectory', async () => {
  return getAutoSavePath();
});

// Data handlers
ipcMain.handle('data:getHistory', async () => {
  return [];
});

ipcMain.handle('data:saveConversion', async (event, record) => {
  console.log('Saving conversion record:', record);
  return true;
});

ipcMain.handle('data:getTemplates', async () => {
  return [];
});

ipcMain.handle('data:saveTemplate', async (event, template) => {
  console.log('Saving template:', template);
  return true;
});

// Settings handlers
ipcMain.handle('settings:get', async (event, key) => {
  return null;
});

ipcMain.handle('settings:set', async (event, key, value) => {
  console.log('Setting:', key, value);
  return true;
});

ipcMain.handle('settings:getAll', async () => {
  return {};
});

// App info handlers
ipcMain.handle('app:getVersion', () => {
  return app.getVersion();
});

ipcMain.handle('app:getPlatform', () => {
  return process.platform;
});

// NOTE: Safety & Packaging Notları
// 1. Keytar kullanılıyorsa: npm run electron-rebuild:keytar
// 2. Client secret kullanılıyorsa: Token exchange main process'te yapılmalı
// 3. Development sırasında detaylı log için: ELECTRON_ENABLE_LOGGING=true
// 4. Stack dump için: ELECTRON_ENABLE_STACK_DUMPING=true
// 5. Native modül hatası varsa: npm run electron-rebuild

// Test talimatları (yorum olarak):
// 1. Terminali yeniden başlat
// 2. npm run dev:main
// 3. Hala crashpad logu geliyorsa tam terminal kapatıp tekrar dene
// 4. Native modül varsa: npm run electron-rebuild